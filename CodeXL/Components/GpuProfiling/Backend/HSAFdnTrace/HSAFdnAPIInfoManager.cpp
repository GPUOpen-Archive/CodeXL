//==============================================================================
// Copyright (c) 2015 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  This class manages all the traces API objects
//==============================================================================

#include <string>
#include <algorithm>
#include "HSAFdnAPIInfoManager.h"
#include "HSAToolsRTModule.h"
#include "HSARTModuleLoader.h"
#include "FinalizerInfoManager.h"
#include "AutoGenerated/HSATraceInterception.h"
#include "AutoGenerated/HSATraceStringOutput.h"
#include "../Common/FileUtils.h"
#include "../Common/GlobalSettings.h"
#include "DeviceInfoUtils.h"
#include "../HSAFdnCommon/HSAFunctionDefsUtils.h"

using namespace std;

HSAAPIInfoManager::HSAAPIInfoManager(void) : m_tracedApiCount(0)
{
    m_strTraceModuleName = "hsa";

    // add APIs that we should always intercept...
    m_mustInterceptAPIs.insert(HSA_API_Type_hsa_queue_create);               // needed so we can create a profiled queue for kernel timestamps
    m_mustInterceptAPIs.insert(HSA_API_Type_hsa_executable_get_symbol);      // needed to extract kernel name
    m_mustInterceptAPIs.insert(HSA_API_Type_hsa_executable_symbol_get_info); // needed to extract kernel name
}

HSAAPIInfoManager::~HSAAPIInfoManager(void)
{
}

bool HSAAPIInfoManager::WriteKernelTimestampEntry(std::ostream& sout, hsa_profiler_kernel_time_t record)
{
    FinalizerInfoManager* pFinalizerInfoMan = FinalizerInfoManager::Instance();

#ifdef _DEBUG
    Log(logMESSAGE, "Lookup %llu\n", record.kernel);

    Log(logMESSAGE, "Dump m_codeHandleToSymbolHandleMap\n");

    for (auto mapItem : pFinalizerInfoMan->m_codeHandleToSymbolHandleMap)
    {
        Log(logMESSAGE, "  Item: %llu == %llu\n", mapItem.first, mapItem.second);

        if (record.kernel == mapItem.first)
        {
            Log(logMESSAGE, "  Match found!\n");
        }
    }

    Log(logMESSAGE, "End Dump m_codeHandleToSymbolHandleMap\n");
#endif

    std::string symName;

    if (pFinalizerInfoMan->m_codeHandleToSymbolHandleMap.count(record.kernel) > 0)
    {
        uint64_t symHandle = pFinalizerInfoMan->m_codeHandleToSymbolHandleMap[record.kernel];

        if (pFinalizerInfoMan->m_symbolHandleToNameMap.count(symHandle) > 0)
        {
            symName = pFinalizerInfoMan->m_symbolHandleToNameMap[symHandle];
            Log(logMESSAGE, "Lookup: CodeHandle: %llu, SymHandle: %llu, symName: %s\n", record.kernel, symHandle, symName.c_str());
        }
    }

    if (symName.empty())
    {
        symName = "<UnknownKernelName>";
    }

    // Kernel name
    sout << std::left << std::setw(max((size_t)50, symName.length() + 1)) << symName;

    // Kernel pointer
    sout << std::left << std::setw(21) << StringUtils::ToHexString(record.kernel);

    // start time
    sout << std::left << std::setw(21) << record.time.start;

    // end time
    sout << std::left << std::setw(21) << record.time.end;

    uint32_t deviceId;
    hsa_status_t status = g_pRealCoreFunctions->hsa_agent_get_info_fn(record.agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_CHIP_ID), &deviceId);

    std::string strDeviceName = "<UnknownDeviceName>";

    if (HSA_STATUS_SUCCESS == status)
    {
        GDT_GfxCardInfo cardInfo;

        // TODO: need to get revision id from HSA runtime (SWDEV-79571)
        if (AMDTDeviceInfoUtils::Instance()->GetDeviceInfo(deviceId, REVISION_ID_ANY, cardInfo))
        {
            strDeviceName = std::string(cardInfo.m_szCALName);
        }
    }

    // agent (device) name
    sout << std::left << std::setw(64) << strDeviceName;

    // agent (device) handle
    sout << std::left << std::setw(21) << HSATraceStringUtils::Get_hsa_agent_t_String(record.agent);

    // queue index
    size_t queueIndex = 0;
    GetQueueIndex(record.queue, queueIndex);
    sout << std::left << std::setw(6) << StringUtils::ToString(queueIndex);

    // queue handle
    sout << std::left << std::setw(21) << StringUtils::ToHexString(record.queue);

    return true;
}

void HSAAPIInfoManager::FlushNonAPITimestampData(std::ostream& sout)
{
    if (HSARTModuleLoader<HSAToolsRTModule>::Instance()->IsLoaded())
    {
        HSAToolsRTModule* toolsRTModule = HSARTModuleLoader<HSAToolsRTModule>::Instance()->GetHSARTModule();

        if (toolsRTModule->IsModuleLoaded())
        {
            size_t count = toolsRTModule->ext_tools_get_kernel_times(0, NULL);

            if (count > 0)
            {
                hsa_profiler_kernel_time_t* records = new(std::nothrow) hsa_profiler_kernel_time_t[count];

                if (NULL != records)
                {
                    count = toolsRTModule->ext_tools_get_kernel_times(count, records);

                    for (size_t i = 0; i < count; i++)
                    {
                        WriteKernelTimestampEntry(sout, records[i]);
                        sout << std::endl;
                    }
                }
                else
                {
                    Log(logERROR, "FlushNonAPITimestampData: unable to allocate memory for kernel timestamps\n");
                }

                delete[] records;
            }
        }
        else
        {
            Log(logERROR, "FlushNonAPITimestampData: tools lib not loaded\n");
        }
    }
}

void HSAAPIInfoManager::AddAPIToFilter(const std::string& strAPIName)
{
    HSA_API_Type type = HSAFunctionDefsUtils::Instance()->ToHSAAPIType(strAPIName);

    if (type != HSA_API_Type_UNKNOWN)
    {
        m_filterAPIs.insert(type);
    }
    else
    {
        Log(logWARNING, "Unknown API name = %s\n", strAPIName.c_str());
    }
}

bool HSAAPIInfoManager::IsInFilterList(HSA_API_Type type) const
{
    return m_filterAPIs.find(type) != m_filterAPIs.end();
}

bool HSAAPIInfoManager::ShouldIntercept(HSA_API_Type type) const
{
    return !IsInFilterList(type) || m_mustInterceptAPIs.find(type) != m_mustInterceptAPIs.end();
}

bool HSAAPIInfoManager::IsCapReached() const
{
    return m_tracedApiCount >= GlobalSettings::GetInstance()->m_params.m_uiMaxNumOfAPICalls;
}

void HSAAPIInfoManager::AddQueue(const hsa_queue_t* pQueue)
{
    if (m_queueIndexMap.end() != m_queueIndexMap.find(pQueue))
    {
        Log(logWARNING, "Queue added to map more than once\n");
    }
    else
    {
        m_queueIndexMap.insert(QueueIndexMapPair(pQueue, m_queueIndexMap.size()));
    }
}

bool HSAAPIInfoManager::GetQueueIndex(const hsa_queue_t* pQueue, size_t& queueIndex) const
{
    bool retVal = false;

    QueueIndexMap::const_iterator it = m_queueIndexMap.find(pQueue);

    if (m_queueIndexMap.end() != it)
    {
        retVal = true;
        queueIndex = it->second;
    }

    return retVal;
}

void HSAAPIInfoManager::AddAPIInfoEntry(APIBase* api)
{
    HSAAPIBase* hsaAPI = dynamic_cast<HSAAPIBase*>(api);

    if (IsCapReached() || IsInFilterList(hsaAPI->m_type) || !IsTracing())
    {
        SAFE_DELETE(hsaAPI);
    }
    else
    {
        APIInfoManagerBase::AddTraceInfoEntry(hsaAPI);
        m_tracedApiCount++;
    }
}
