//==============================================================================
// Copyright (c) 2015 Advanced Micro Devices, Inc. All rights reserved.
/// \author AMD Developer Tools Team
/// \file
/// \brief  This file is the main agent file for the HSA API Trace module
//==============================================================================

#include <hsa_api_trace.h>

#include <cstdlib>
#include <iostream>

#include "Logger.h"
#include "FileUtils.h"
#include "GlobalSettings.h"
#include "StackTracer.h"

#include "HSATraceInterceptionTable1_0.h"
#include "HSAAgentUtils.h"

#include "HSAFdnAPIInfoManager.h"
#include "AutoGenerated/HSATraceInterception.h"
#include "AutoGenerated/HSACoreAPITraceClasses.h"


void TimerThread(void* param)
{
    SP_UNREFERENCED_PARAMETER(param);

    unsigned int interval = HSAAPIInfoManager::Instance()->GetInterval();

    if (interval == 0)
    {
        interval = 1; // safety net in case interval is zero (it shouldn't be...)
    }

    const unsigned int sleepInterval = interval < 10 ? interval : 10; // sleep at most 10 ms at a time
    const unsigned int sleepsBeforeFlush = sleepInterval == 0 ? 1 : interval / sleepInterval;

    unsigned int iterationNum = 1;

    while (HSAAPIInfoManager::Instance()->IsRunning())
    {
        OSUtils::Instance()->SleepMillisecond(sleepInterval);

        if (iterationNum == sleepsBeforeFlush)
        {
            iterationNum = 1;
            HSAAPIInfoManager::Instance()->TrySwapBuffer();
            HSAAPIInfoManager::Instance()->FlushTraceData();
        }
        else
        {
            iterationNum++;
        }
    }
}

extern "C" DLL_PUBLIC void amdtCodeXLStopProfiling()
{
    HSAAPIInfoManager::Instance()->StopTracing();
}

extern "C" DLL_PUBLIC void amdtCodeXLResumeProfiling()
{
    HSAAPIInfoManager::Instance()->ResumeTracing();
}

extern "C" bool DLL_PUBLIC OnLoad(void* pTable, uint64_t runtimeVersion, uint64_t failedToolCount, const char* const* pFailedToolNames)
{
#ifdef _DEBUG
    FileUtils::CheckForDebuggerAttach();
#endif

    std::string strLogFile = FileUtils::GetDefaultOutputPath() + "hsatraceagent.log";
    LogFileInitialize(strLogFile.c_str());

    if (!CheckRuntimeToolsLibLoaded(runtimeVersion, failedToolCount, pFailedToolNames))
    {
        std::cout << "CodeXL GPU Profiler could not be enabled. Version mismatch between HSA runtime and " << HSA_RUNTIME_TOOLS_LIB << std::endl;
        return false;
    }

    std::cout << "CodeXL GPU Profiler " << GPUPROFILER_BACKEND_VERSION_STRING << " is enabled\n";

    Parameters params;
    FileUtils::GetParametersFromFile(params);

    if (params.m_bStartDisabled)
    {
        HSAAPIInfoManager::Instance()->StopTracing();
    }

    GlobalSettings::GetInstance()->m_params = params;
    HSAAPIInfoManager::Instance()->SetOutputFile(params.m_strOutputFile);

    if (!params.m_strAPIFilterFile.empty())
    {
        HSAAPIInfoManager::Instance()->LoadAPIFilterFile(params.m_strAPIFilterFile);
    }

    StackTracer::Instance()->InitSymPath();

    if (params.m_bTimeOutBasedOutput)
    {
        HSAAPIInfoManager::Instance()->SetInterval(params.m_uiTimeOutInterval);

        if (!HSAAPIInfoManager::Instance()->StartTimer(TimerThread))
        {
            std::cout << "Failed to initialize HSATraceAgent.\n";
        }
    }

    if (0 == runtimeVersion)
    {
        // ROCm versions 1.1.1 and earlier
        InitHSAAPIInterceptTrace1_0(reinterpret_cast<ApiTable1_0*>(pTable));
    }
    else
    {
        InitHSAAPIInterceptTrace(reinterpret_cast<HsaApiTable*>(pTable));
    }

    // Add a fabricated entry for hsa_init when OnLoad is called.
    // OnLoad is called when the first hsa_init is called.
    // The timestamps are made up, but at least there is an entry.
    // The retVal is always HSA_STATUS_SUCCESS because if the RT were to
    // return anything else, this OnLoad function wouldn't get called.
    ULONGLONG ullStart = OSUtils::Instance()->GetTimeNanos();
    hsa_status_t retVal = HSA_STATUS_SUCCESS;

    HSA_APITrace_hsa_init* pAPIInfo = new(std::nothrow) HSA_APITrace_hsa_init();
    SpAssertRet(pAPIInfo != NULL) false;

    ULONGLONG ullEnd = OSUtils::Instance()->GetTimeNanos();

    pAPIInfo->Create(
        ullStart,
        ullEnd,
        retVal);

    RECORD_STACK_TRACE_FOR_API(pAPIInfo);
    HSAAPIInfoManager::Instance()->AddAPIInfoEntry(pAPIInfo);

    return true;
}

extern "C" void DLL_PUBLIC OnUnload()
{
    // Add a fabricated entry for hsa_shut_down when OnUnload is called.
    // OnUnload is called when the last hsa_shut_down is called (i.e. refcount goes to zero).
    // The timestamps are made up, but at least there is an entry.
    // The retVal is always HSA_STATUS_SUCCESS because if the RT were to
    // return anything else, this OnUnload function wouldn't get called.
    ULONGLONG ullStart = OSUtils::Instance()->GetTimeNanos();
    hsa_status_t retVal = HSA_STATUS_SUCCESS;

    HSA_APITrace_hsa_shut_down* pAPIInfo = new(std::nothrow) HSA_APITrace_hsa_shut_down();
    SpAssertRet(pAPIInfo != NULL);

    ULONGLONG ullEnd = OSUtils::Instance()->GetTimeNanos();

    pAPIInfo->Create(
        ullStart,
        ullEnd,
        retVal);

    RECORD_STACK_TRACE_FOR_API(pAPIInfo);
    HSAAPIInfoManager::Instance()->AddAPIInfoEntry(pAPIInfo);

    if (HSAAPIInfoManager::Instance()->IsTimeOutMode())
    {
        HSAAPIInfoManager::Instance()->StopTimer();
        HSAAPIInfoManager::Instance()->TrySwapBuffer();
        HSAAPIInfoManager::Instance()->FlushTraceData();
        HSAAPIInfoManager::Instance()->TrySwapBuffer();
        HSAAPIInfoManager::Instance()->FlushTraceData();
        HSAAPIInfoManager::Instance()->ResumeTimer();
    }

    DoneHSAAPIInterceptTrace();
}

